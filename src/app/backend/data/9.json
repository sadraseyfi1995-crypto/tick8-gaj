[
  {
    "id": 1,
    "word": "Largest Contentful Paint (LCP)",
    "answer": "Measures loading performance. Time to render the largest image or text block visible in viewport.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 2,
    "word": "Cumulative Layout Shift (CLS)",
    "answer": "Measures visual stability. Sum of layout shifts occurring during viewport-visible lifespan.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 3,
    "word": "Interaction to Next Paint (INP)",
    "answer": "Measures responsiveness. Latency from user interaction to next paint update.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 4,
    "word": "First Contentful Paint (FCP)",
    "answer": "Time from navigation to first text/image/content render in viewport.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 5,
    "word": "Time to First Byte (TTFB)",
    "answer": "Time between request and first byte of response from server.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 6,
    "word": "DOM Content Loaded",
    "answer": "Event fired when initial HTML document is completely loaded and parsed.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 7,
    "word": "First Input Delay (FID)",
    "answer": "Time from first user interaction to browser response processing.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 8,
    "word": "Total Blocking Time (TBT)",
    "answer": "Sum of blocking time between FCP and Time to Interactive.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 9,
    "word": "Speed Index",
    "answer": "Measures how quickly content is visually displayed during page load.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 10,
    "word": "Layout Shift",
    "answer": "Unexpected movement of visible elements within viewport during loading.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 11,
    "word": "Render Blocking Resources",
    "answer": "CSS/JS files that prevent page rendering until downloaded and parsed.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 12,
    "word": "Critical Rendering Path",
    "answer": "Sequence of steps browser takes to convert HTML/CSS/JS into pixels.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 13,
    "word": "DOM Construction",
    "answer": "Browser process of parsing HTML and building Document Object Model.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 14,
    "word": "CSS Object Model (CSSOM)",
    "answer": "Browser's representation of CSS styles as structured, queryable object.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 15,
    "word": "Render Tree",
    "answer": "Combination of DOM and CSSOM representing what will be rendered.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 16,
    "word": "Layout/Reflow",
    "answer": "Browser process calculating exact position/size of each visible element.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 17,
    "word": "Paint",
    "answer": "Process of filling pixels for text, colors, images, borders, shadows.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 18,
    "word": "Compositing",
    "answer": "Browser process combining different painted layers into final screen image.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 19,
    "word": "Parser Blocking",
    "answer": "When JavaScript execution stops HTML parsing until script completes.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 20,
    "word": "Minimizing Critical Path",
    "answer": "Reducing steps and resources needed for first render of page.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 21,
    "word": "Long Tasks",
    "answer": "JavaScript tasks taking over 50ms that block main thread execution.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 22,
    "word": "Main Thread",
    "answer": "Browser thread handling parsing, layout, JavaScript, and painting.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 23,
    "word": "Task Scheduling",
    "answer": "Browser's prioritization system for executing different types of work.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 24,
    "word": "requestAnimationFrame",
    "answer": "API for scheduling visual updates before next browser repaint cycle.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 25,
    "word": "requestIdleCallback",
    "answer": "API for scheduling non-urgent work during browser idle periods.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 26,
    "word": "Web Workers",
    "answer": "JavaScript scripts running in background threads separate from main.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 27,
    "word": "Task Splitting",
    "answer": "Breaking long JavaScript operations into smaller, non-blocking chunks.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 28,
    "word": "Yielding to Main Thread",
    "answer": "Intentionally pausing JavaScript to allow browser rendering/input.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 29,
    "word": "Input Debouncing",
    "answer": "Limiting rate of input event handler executions to improve performance.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 30,
    "word": "Event Throttling",
    "answer": "Controlling how frequently event handlers fire during continuous actions.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 31,
    "word": "Memory Management",
    "answer": "Preventing memory leaks and excessive garbage collection pauses.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 32,
    "word": "JavaScript Chunking",
    "answer": "Breaking large JavaScript operations into smaller asynchronous pieces.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 33,
    "word": "Progressive Loading",
    "answer": "Loading content gradually as user interacts with page, not all upfront.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 34,
    "word": "Frame Rate Consistency",
    "answer": "Maintaining steady 60fps updates without jank or stuttering.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 35,
    "word": "Input Latency",
    "answer": "Delay between user action and visible response on screen.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 36,
    "word": "Main Thread Contention",
    "answer": "Competition between tasks preventing timely input response and rendering.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 37,
    "word": "Task Prioritization",
    "answer": "Giving user-interactive tasks higher priority over background work.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 38,
    "word": "Bundle Splitting",
    "answer": "Dividing JavaScript into multiple files loaded based on route/feature.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 39,
    "word": "Dynamic Import",
    "answer": "Loading JavaScript modules on-demand when needed, not initially.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 40,
    "word": "Route-Based Splitting",
    "answer": "Splitting code so each route loads only JavaScript needed for that page.",
    "states": [
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none",
      "none"
    ]
  },
  {
    "id": 41,
    "word": "Component-Level Splitting",
    "answer": "Code-splitting at individual component level for granular lazy loading."
  },
  {
    "id": 42,
    "word": "Vendor Splitting",
    "answer": "Separating third-party library code from application business logic."
  },
  {
    "id": 43,
    "word": "Lazy Loading Images",
    "answer": "Loading images only when they're about to enter viewport."
  },
  {
    "id": 44,
    "word": "Conditional Fetching",
    "answer": "Loading data/resources only when specific conditions are met."
  },
  {
    "id": 45,
    "word": "Tree Shaking",
    "answer": "Build-time elimination of unused JavaScript code from final bundles."
  },
  {
    "id": 46,
    "word": "Chunk Optimization",
    "answer": "Balancing bundle sizes for optimal loading and caching performance."
  },
  {
    "id": 47,
    "word": "Async Components",
    "answer": "Components loaded asynchronously only when needed for rendering."
  },
  {
    "id": 48,
    "word": "Progressive Hydration",
    "answer": "Gradually making server-rendered content interactive in priority order."
  },
  {
    "id": 49,
    "word": "Intersection Observer",
    "answer": "API detecting when elements become visible in viewport for loading."
  },
  {
    "id": 50,
    "word": "Loading States",
    "answer": "UI feedback shown while asynchronously loaded content is pending."
  },
  {
    "id": 51,
    "word": "Error Boundaries",
    "answer": "React components catching JavaScript errors in lazy-loaded modules."
  },
  {
    "id": 52,
    "word": "Bundle Analysis",
    "answer": "Examining compiled JavaScript bundles to identify optimization opportunities."
  },
  {
    "id": 53,
    "word": "Prefetch",
    "answer": "Hint to browser to fetch resource likely needed for future navigation."
  },
  {
    "id": 54,
    "word": "Preload",
    "answer": "Hint to browser to fetch critical resource early in current page load."
  },
  {
    "id": 55,
    "word": "Preconnect",
    "answer": "Hint to browser to establish early connection to another origin."
  },
  {
    "id": 56,
    "word": "DNS-Prefetch",
    "answer": "Hint to browser to perform DNS lookup for domain in advance."
  },
  {
    "id": 57,
    "word": "Prerender",
    "answer": "Hint to browser to load and render entire page in background."
  },
  {
    "id": 58,
    "word": "Resource Prioritization",
    "answer": "Using hints to tell browser loading order for different resources."
  },
  {
    "id": 59,
    "word": "Early Hint",
    "answer": "HTTP header sending resource hints before final response is ready."
  },
  {
    "id": 60,
    "word": "Critical Resource Preloading",
    "answer": "Using preload for fonts, CSS, JS essential for initial render."
  },
  {
    "id": 61,
    "word": "Font Preloading",
    "answer": "Loading web fonts early to prevent flash of unstyled text."
  },
  {
    "id": 62,
    "word": "Image Preloading",
    "answer": "Loading important above-fold images before they're naturally requested."
  },
  {
    "id": 63,
    "word": "Script Preloading",
    "answer": "Loading critical JavaScript modules with high priority."
  },
  {
    "id": 64,
    "word": "Cross-Origin Prefetch",
    "answer": "Prefetching resources from different domains for future navigation."
  },
  {
    "id": 65,
    "word": "Link Header Hints",
    "answer": "Sending resource hints via HTTP Link headers instead of HTML."
  },
  {
    "id": 66,
    "word": "Speculative Loading",
    "answer": "Loading resources based on predicted user actions before they occur."
  },
  {
    "id": 67,
    "word": "Browser Preload Scanner",
    "answer": "Browser component parsing HTML and queuing resources before main parser."
  },
  {
    "id": 68,
    "word": "Hint Priority Management",
    "answer": "Balancing multiple resource hints to avoid bandwidth contention."
  },
  {
    "id": 69,
    "word": "Cache-Aware Preloading",
    "answer": "Only preloading resources not already in browser cache."
  },
  {
    "id": 70,
    "word": "Network-Aware Preloading",
    "answer": "Adapting preloading strategy based on user's network conditions."
  },
  {
    "id": 71,
    "word": "First Paint",
    "answer": "First time browser paints anything to screen during navigation."
  },
  {
    "id": 72,
    "word": "First Meaningful Paint",
    "answer": "Point when primary content appears and becomes useful to user."
  },
  {
    "id": 73,
    "word": "Time to Interactive",
    "answer": "When page becomes fully interactive and responds quickly to input."
  },
  {
    "id": 74,
    "word": "Optimistic Prefetching",
    "answer": "Prefetching resources for most likely user paths, not all possibilities."
  },
  {
    "id": 75,
    "word": "Lazy Hydration",
    "answer": "Delaying JavaScript interactivity until components are nearly visible."
  },
  {
    "id": 76,
    "word": "Server Push",
    "answer": "HTTP/2 feature sending resources to client before they're requested."
  },
  {
    "id": 77,
    "word": "Compression",
    "answer": "Reducing file sizes through gzip, Brotli for faster transfers."
  },
  {
    "id": 78,
    "word": "Minification",
    "answer": "Removing unnecessary characters from code without changing functionality."
  },
  {
    "id": 79,
    "word": "Caching Strategies",
    "answer": "Rules determining how long resources stay in browser cache."
  },
  {
    "id": 80,
    "word": "Content Visibility",
    "answer": "CSS property skipping rendering work for off-screen content."
  },
  {
    "id": 81,
    "word": "Containment",
    "answer": "CSS property isolating element's styling/layout for performance."
  },
  {
    "id": 82,
    "word": "Eager Loading",
    "answer": "Loading resource immediately rather than waiting for interaction."
  },
  {
    "id": 83,
    "word": "Connection Reuse",
    "answer": "Using existing network connections rather than establishing new ones."
  },
  {
    "id": 84,
    "word": "Speculative Parsing",
    "answer": "Browser scanning ahead in HTML to discover and load resources early."
  },
  {
    "id": 85,
    "word": "Render Prioritization",
    "answer": "Browser deciding which content to paint first based on visibility."
  },
  {
    "id": 86,
    "word": "Layout Thrashing",
    "answer": "Multiple forced synchronous layouts causing performance bottlenecks."
  },
  {
    "id": 87,
    "word": "Jank",
    "answer": "Visible stuttering or uneven motion in animations/scrolling."
  },
  {
    "id": 88,
    "word": "Main Thread Work",
    "answer": "Any task running on primary browser thread that blocks others."
  },
  {
    "id": 89,
    "word": "Offscreen Rendering",
    "answer": "Rendering content outside viewport for smooth scrolling experience."
  },
  {
    "id": 90,
    "word": "Progressive Enhancement",
    "answer": "Building core experience first, then enhancing with JavaScript."
  },
  {
    "id": 91,
    "word": "Static Generation",
    "answer": "Pre-building pages at compile time rather than request time."
  },
  {
    "id": 92,
    "word": "Incremental Static Regeneration",
    "answer": "Updating static content after build without full rebuild."
  },
  {
    "id": 93,
    "word": "Edge Caching",
    "answer": "Storing content at CDN edges closer to users for faster delivery."
  },
  {
    "id": 94,
    "word": "Browser Cache",
    "answer": "Local storage of resources to avoid re-downloading on revisit."
  },
  {
    "id": 95,
    "word": "Service Worker Caching",
    "answer": "Programmatic control over cache storage and network requests."
  },
  {
    "id": 96,
    "word": "Cache Invalidation",
    "answer": "Process of removing outdated cached resources when content changes."
  },
  {
    "id": 97,
    "word": "Warm Connection",
    "answer": "Reusing established network connection to avoid TCP/TLS handshake."
  },
  {
    "id": 98,
    "word": "Predictive Prefetch",
    "answer": "Using machine learning to anticipate and preload user navigation paths."
  },
  {
    "id": 99,
    "word": "Resource Timing API",
    "answer": "Browser API providing detailed timing information for resource loads."
  },
  {
    "id": 100,
    "word": "Navigation Timing API",
    "answer": "Browser API measuring performance metrics for page navigation."
  }
]